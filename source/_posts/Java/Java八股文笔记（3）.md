---
title: Java八股文笔记（3）
date: '2023-07-08 16:21:37'
description: 面试小抄，Java八股文笔记
categories: 
  - Java
tags:
  - Java
  - 面经
---

## HashMap常问面试题

### 能否使用任何类作为 Map 的 key？

可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点： 如果类重写了 equals() 方法，也应该重写 hashCode() 方法。类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。

**如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。**

### 为什么HashMap中String、Integer这样的包装类适合作为Key？

String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少
Hash碰撞的几率。而且都是final类型，即不可变性，保证key的不可更改性，不会存在获取 hash值不同情况。

内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（即putValue的过程），不容易出现Hash值计算错误的情况

### 为何要用红黑数？为何一上来不树化？树化阈值为何是8？何时会树化，何时会退化为链表？

1. 红黑树用来避免DoS攻击，防止链表超长时性能下降，树化应当是偶然情况

1. hash表的查找，更新的时间复杂度时O(1)，而红黑树的查找，更新的时间复杂度是O(log2n)，TreeNode占用空间也比普通Node的大，如非必要，尽量还是使用链表。
2. hash值如果足够随机，则在hash表内按泊松分布，在负载因子0.75的情况下，长度超过8的链表出现概率是0.00000006，选择8就是为了让树化几率足够小。
3. 树化两个条件：链表长度超过树化阈值（8）；数组容量>=64

3.退化情况：

1. 在扩容时如果拆分树时，树元素个数<=6则会退化链表
2. 移除树节点时，若root、root.left、root.right、root.left.left有一个为null，也会退化为链表（不适用于扩容时的情况）

### 索引如何计算？hashCode都有了，为何还要提供hash()方法？数组容量为何是2的n次幂？

1. 计算对象的hashCode()，再进行调用HashMap的hash()方法进行二次哈希，最后&(capacity-1)得到索引
2. 二次hash()是为了综合高位数据，让哈希分布更为均匀
3. 计算索引时，如果是2的n次幂可以使用位与运算代替取模，效率更高；扩容时hash&oldCapacity==0的元素留在原来位置，否则新位置=旧位置+oldCapacity
4. 但前三点都是为了配合容量为2的n次幂时的优化手段，例如HashTable的容量就不是2的n次幂，并不能说明哪种设计更优，应该是设计者综合了各种因素，最终选择了使用2的n次幂作为容量

### 介绍一下put方法流程，1.7与1.8有何不同？

1. HashMap是懒惰创建数组的，首次使用才创建数组
2. 计算索引（桶下标）
3. 如果桶下标还没被占用，创建Node占位返回
4. 如果桶下标已经被占用

- 是Tree Node，走红黑树的添加或更新逻辑
- 是普通Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑
- 返回前检查容量是否超过阈值，一旦超过则进行扩容
- 不同

- 链表插入节点时，1.7是头插法，1.8是尾插法
- 1.7是大于等于阈值且没有空位时才扩容，而1.8是大于阈值就扩容
- 1.8在扩容计算Node索引时，会优化

### 负载因子为何默认是0.75f

1. 在空间占用与查询时间之间取得较好的权衡
2. 大于这个值，空间节省了，但链表就会比较长影响性能
3. 小于这个值，冲突减少了，但扩容就会更频繁，空间占用多